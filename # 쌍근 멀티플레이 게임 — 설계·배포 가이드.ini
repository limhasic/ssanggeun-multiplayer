# 쌍근 멀티플레이 게임 — 설계·배포 가이드

한국어 두글자 단어 추리 게임 "쌍근"의 멀티플레이(실시간/턴제) 버전을 만들고 배포하는 전체 로드맵, 기술 스택 추천, 아키텍처, 핵심 구현 샘플, 배포 옵션, 운영 체크리스트를 한 문서에 정리했습니다.

---

## 1. 목표(한 줄)

* 플레이어들이 실시간으로(또는 턴제 매치로) 서로 맞대결하는 **쌍근** 게임을 웹/모바일에서 즐길 수 있도록 만들어 배포한다.

---

## 2. 핵심 요구사항(MVP)

1. 1:1 매치 메이킹(또는 관전자 포함 가능한 룸)
2. 각 플레이어는 **정답(서버가 배정)** 을 가지고 7턴 동안 추리
3. 각 턴마다 입력 단어에 대해 자모 단위 힌트(🥕🍄🧄🍆🍌🍎)를 반환
4. 호박(🎃) 힌트(각 게임당 1회, 사용 선택 가능)와 다래(대체 힌트) 기능
5. 승패 판정(7턴 이내 정답 맞히면 승리, 아니면 패배) + 결과 이모지(🥕🥕 또는 🐯)
6. 채팅(선택) 및 리더보드(점수 집계)
7. 기본한글 자모 분해/판정 로직을 정확히 구현

---

## 3. 추천 아키텍처 (요약)

* **Frontend:** React (Next.js) — SSR/SSG로 SEO/공유 카드 지원, Vercel 배포 가능
* **Realtime:** WebSocket (Socket.IO) 또는 WebRTC 데이터채널(피어투피어). 권장: **Socket.IO** (간단하고 안정적)
* **Backend:** Node.js + Express (or Fastify) + Socket.IO
* **DB:** PostgreSQL (게임 기록, 사용자, 리더보드), Redis (매치메이킹, 세션, 실시간 상태 캐시)
* **Auth:** OAuth (구글/애플/카카오) 및 익명 게스트 토큰 (JWT)
* **배포:** Vercel(프론트) + Railway/Render/AWS Elastic Beanstalk/Heroku(백엔드) + Supabase/PlanetScale/Postgres(데이터)
* **CI/CD:** GitHub Actions

---

## 4. 게임 플로우 (멀티플레이, 1:1 실시간)

1. 플레이어 A가 매치메이킹 요청 → Redis에 대기 큐 등록
2. 플레이어 B가 매칭 → 서버가 룸 생성, 정답 단어 2개(각 플레이어용)를 서버가 할당
3. 소켓을 통해 룸 입장, 초기 상태 전송(턴카운트=0, 각자 남은 호박=1 등)
4. 플레이어가 단어 입력 → `guess` 이벤트로 서버 전송
5. 서버에서 자모 분해 후 판정 알고리즘 실행 → 각 플레이어에게 힌트 이벤트 송신
6. 플레이어가 정답을 맞히면 서버가 승리/종료 처리(점수 기록)
7. 7턴 초과 시 실패 처리, 정답 공개

---

## 5. 데이터 모델 (핵심)

* **users**: id, display_name, avatar_url, provider, created_at
* **games**: id, type(1v1), state(enum: waiting, playing, finished), created_at, finished_at
* **game_players**: id, game_id, user_id(optional), role(playerA/playerB), secret_word, guesses(jsonb), used_pumpkin(bool), score
* **words**: id, word, jamo_decomposed(jsonb)  // 사전
* **leaderboard**: user_id, wins, losses, elo(optional)

---

## 6. 자모 분해·판정 로직 요약 (서버측)

* 겹받침(ㄳ, ㄵ 등) → 각 자모로 분리. 예: ㄳ → ㄱ + ㅅ
* 합모음(ㅘ, ㅚ 등) → 포함된 중성 자모들로 간주(ㅗ+ㅏ, ㅗ+ㅣ)
* 쌍자음(ㄲ, ㅃ, ㅉ)과 ㅐ,ㅒ,ㅔ,ㅖ 등은 별개 자모로 인식

판정 우선순위 (한 글자 기준):

1. 글자 전체 일치 → 🥕
2. 초성 일치 & (중성 또는 종성 중 하나) 일치 → 🍄
3. 초성 불일치 & (임의의 자모 2개 이상 일치) → 🧄
4. 자모 1개만 일치 → 🍆
5. 해당 글자의 자모는 없으나 반대편 글자에 1개 이상 존재 → 🍌
6. 완전 불일치 → 🍎

서버는 각 턴에 대해 각 글자(앞글자/뒷글자) 판정을 만들어 양 플레이어에게 전송한다.

---

## 7. 실시간 통신 (Socket.IO) 주요 이벤트 제안

* `connect`, `disconnect`
* `join_queue` / `leave_queue`
* `match_found` (roomId, opponentInfo, yourRole)
* `room_joined` (room state)
* `make_guess` {roomId, guess}
* `guess_result` {roomId, guess, hintsPerLetter, pumpkinAvailable}
* `use_pumpkin` (returns one jamo hint)
* `game_over` {result, winner, solution}
* `chat_message` (선택)

---

## 8. 간단한 서버 샘플 (Node.js + Express + Socket.IO)

```js
// server.js (핵심 흐름만 발췌)
const express = require('express');
const http = require('http');
const { Server } = require('socket.io');
const { judgeWord, decompose } = require('./jamo-judge'); // 자모 로직 파일

const app = express();
const server = http.createServer(app);
const io = new Server(server, { cors: { origin: '*' } });

io.on('connection', socket => {
  socket.on('join_queue', () => { /* 매칭 큐에 넣기 (Redis 권장) */ });
  socket.on('make_guess', ({ roomId, guess }) => {
    const game = getGame(roomId); // 메모리/DB에서
    const result = judgeWord(game.secretFor(socket.id), guess);
    io.to(roomId).emit('guess_result', { guess, result });
    // 승리/종료 체크
  });
});

server.listen(process.env.PORT || 3001);
```

> `jamo-judge.js`는 한글 분해와 위 판정 규칙을 정확히 구현한 모듈이어야 합니다. (유닛 테스트 중요)

---

## 9. 프론트엔드(React/Next.js) 핵심 구성

* 로그인/게스트 모드
* 매칭 화면(대기 애니메이션)
* 게임 룸 컴포넌트

  * 키보드(자모 버튼)와 입력창
  * 2x2 결과 그리드(각 칸에 아이콘/색 표시)
  * 호박 버튼과 사용 카운트
  * 채팅/타이머
* 결과화면(승리/패배/리플레이 버튼)

UI는 모바일 우선으로 설계. 한글 입력을 직접 받기보다 자모 키보드를 제공하면 판정의 일관성 확보에 좋음.

---

## 10. 배포 옵션 (간단 비교)

* **Vercel + Railway** (권장 빠른 MVP)

  * 프론트: Vercel (Next.js) — 무료 시작 가능
  * 백엔드: Railway 또는 Render (Node + Socket.IO 지원)
  * DB: Railway Postgres / Supabase
  * Redis: Upstash 또는 Railway Redis

* **AWS** (프로덕션 스케일)

  * EC2/ECS + ELB + RDS(Postgres) + ElastiCache(Redis)
  * 비용 복잡도 ↑, 제어력 ↑

* **Firebase / Supabase** (서버리스 접근)

  * Realtime 기능은 한계가 있고 커스텀 Socket.IO가 필요하면 Functions로 구성

---

## 11. 운영·모니터링·보안 체크리스트

* HTTPS 강제
* CORS 정책 제한
* 세션 보안(JWT 만료, 토큰 리프레시)
* 레이트 리미트(입력 스팸·봇 방지)
* 부정행위 탐지(짧은 시간 내 정답 맞추기 등 이상 패턴 로깅)
* 로그(플레이어 행동, 에러) 수집 → Sentry/Datadog
* DB 백업 및 자동 스냅샷

---

## 12. 테스트 및 QA

* 유닛테스트: 자모 분해·판정 모듈 (Mocha/Jest)
* 통합테스트: 게임 시나리오(매치메이킹 → 플레이 → 종료)
* 부하테스트: Socket 연결 수와 동시 게임 수 (k6, Artillery)
* 사용자 테스트: 크라우드테스트(채용 베타 테스터)

---

## 13. 추가 기능(롤아웃 순)

1. 관전자 모드(관전 + 응원 채팅)
2. 커스텀 룰(턴수 조절, 호박 사용 제한 등)
3. 토너먼트 모드(랭킹전)
4. 친구초대·초대코드로 1:1 대결
5. 한국어 외 지역화(설명·아이콘 번역)

---

## 14. 수익화 아이디어

* 광고(중간/후원형 배너)
* 시즌 패스(스킨, 사용자 이모지)
* 유료로 추가 힌트(호박 추가 구매) — 주의: 공정성 문제

---

## 15. 시간/리소스(개발팀 예시)

* 1~2명 (풀스택)로 MVP: 약 4~8주(기능 우선순위에 따라 달라짐)
* 3~5명으로 더 완성도 높은 프로덕션: 2~3개월

(참고: 위 기간은 매우 대략적입니다. 지금 당장 상세한 업무분할과 스프린트 계획을 만들어드릴 수 있습니다.)

---

## 16. 시작 코드/레포 구조 제안

```
/README.md
/frontend  (Next.js)
  /pages
  /components
  /lib/socket.ts
/backend   (Node/Express)
  /src
    server.js
    jamo-judge.js
    matchmaker.js
  /tests

/scripts/deploy.sh
```

---

## 17. 다음으로 제가 도와드릴 수 있는 것

원하시는 항목을 골라 주세요. 즉시 작업해서 산출물을 드립니다:

* [ ] **핵심 자모 판정 모듈** (Node.js 구현 + 유닛테스트)
* [ ] **간단한 Socket.IO 서버 + 매칭 예제** (로컬에서 실행 가능한 샘플)
* [ ] **Next.js 게임 클라이언트(한 글자 입력 UI + 힌트 렌더링)**
* [ ] **전체 README + 배포 스크립트** (Vercel + Railway 가이드 포함)
* [ ] **프로젝트 작업 분할(스프린트·티켓) + 대략 인력/일정**

원하시는 항목 번호를 알려주시면, 바로 해당 산출물을 만들어 드릴게요.

---

끝.
